# 알고리즘 - 효율적으로 문제를 해결하는 방식
# 저장 구조 - data를 저장하거나 관리하는 방식

# 선형 구조 - list(array) / linked list
# list는 값을 추가하거나 제거할 때 공백을 없게 하기 위해 앞뒤로 당기거나 민다
# 자료를 추가 삭제가 잦으면 느리다 불리하다
# 탐색할 때 for / while 문을 통해서 탐색

# 비선형 구조
# graph
# 탐색할 때  DFS / BFS 탐색 방법을 사용하여 탐색

# 데이터를 관리하거나 사용하는 방법으로는 stack과 queue를 사용

# queue : First In First Out / stack : First In Last Out

# Queue
# 맛집에 줄을 세워서 줄 선 순서대로 입장하고 가장 먼저 들어온 손님부터 음식을 내줌

# Stack
# 뒤로가기 버튼 / 가장 마지막에 봤던 페이지를 렌더 해서 보여줌

"""
graph
      A
    B   C
  D   E

트리 모양의 그래프

특징 1) 부모 자식 관계를 갖는다
예) A의 자식은 B와 C / B의 자식은 D와 E
특징 2) 단방향이다
특징 3) cycle이 구주적으로 발생할 수 없다
최상위 부모를 '루트 노드'
나머지 '리프 노드'

트리 모양의 그래프가 아닌 구조는 단방향일 수도 있고 양방향일 수도 있고 (무방향 : 방향 표시 하지 않으면 전부 양방향)

트리 모양의 그래프를 코드로 표현하기
(인접행렬, 인접리스트, 1차원 리스트에 이진 트리 상태를 저장해서)

0번 인덱스 : A, 1번 인덱스 : B, 2번 인덱스 : C, 3번 인덱스 : D, 4번 인덱스 : E 라고 가정

1) 인접 행렬 (2차원 리스트)
  A B C D E
A 0 1 1 0 0
B 0 0 0 1 1
C 0 0 0 0 0
D 0 0 0 0 0
E 0 0 0 0 0

이동할 수 있는 리스트를 1로 체크

2) 인접 리스트
A 0 - [1, 2]
B 1 - [3, 4]
C 2
D 3
E 4

이동할 수 있는 인덱스를 리스트로 표현

3) 1차원 리스트
항상 루트 노드를 1번 인덱스에 저장
부모의 왼쪽은 부모인덱스 * 에 저장됨 / 오른쪽은 부모인덱스 * 2 + 1 에 저장됨

1 A / 2 B / 3 C / 4 D/ 5 E
[_, A, B, C, D, E, _, _]

인접행렬과 인접리스트의 차이
1) 모든 노드(data)를 탐색할 때
인접 행렬은 2중 for문을 통해서 전부 탐색
인접리스트는 갈 수 있는 곳이 없으면 탐색하지 않음
따라서 인접리스트가 인접행렬보다 빠르게 탐색할 수 있다

2) 특정 노드의 상황을 파악하려 할 때
예) B에서 E 이동 가능?
인접리스트는 n 번 탐색 O(n)의 속도
인접행렬은 (B, E) 위치만 탐색 O(1)의 속도
특정 노드 탐색은 인접행렬이 인접리스트 보다 빠르게 탐색할 수 있다
"""

# DFS = Depth First Search (깊이 우선 탐색)
# 재귀함수와 탐색 순서가 유사
# A -> B, A -> C / B -> D, B -> E / C -> F
# 0 : A / 1 : B / 2 : C / 3 : D / 4 : E / 5 : F
# A -> B -> D return -> B -> E return -> B return -> A -> C -> F return -> C return -> A

# A부터 탐색을 시작해서 탐색하는 순서 출력
# A 부터 탐색하다가 첫번째 1을 발견하면 첫번째 1로 이동
# 계속해서 탐색하다가 갈 곳이 없다면 함수 호출 된 곳으로 return

# 그래프는 노드들끼리 연결이 되어 있다 안되어 있다가 중요한게 아님
# 노드는 필수요소지만 간선은 필수요소가 아님
# 직간접적으로 연결되어 있는 것들을 연결 요소 라고 부를 거임
# 단일 노드만 있어도 연결 요소 1개로 측정
# 연결 요소의 크기는 노드의 개수를 의미함

# DFS, BFS 모두 되는 문제는 보통 연결 요소 문제
# DFS 문제 => 경로 정보, 이전으로 들어간다, 이제까지 왔던 길에 이것들이 몇개 있냐
# BFS 문제 => 최단 거리

# 양방향 연결이 되어 있을 경우 방문 처리를 함으로써 cycle을 방지한다
# 방문처리가 되었더라도 함수가 끝이 나면 함수가 호출 됐던 곳으로 return
# 같은 연결 요소에 있는 노드는 방문 처리를 할 수 있다 -> dfs를 다 돌리면 전부 방문 처리가 된다
# 시작노드 s 끝 노드 e
# s에서 e를 갈 수 있나? -> s에서 dfs 를 전부 돌리고 e가 방문처리 되어 있는지 확인한다
# s가 포함된 연결요소의 크기 구하기 -> s에서 dfs 돌린 후 방문처리된 노드의 수 구하기
# 연결 요소의 개수 -> 방문 안한 노드를 볼 때마다 카운트 하기

# A부터 탐색을 시작해서 탐색하는 순서 출력
# A 부터 탐색하다가 첫번째 1을 발견하면 첫번째 1로 이동
# 계속해서 탐색하다가 갈 곳이 없다면 함수 호출 된 곳으로 return

# DFS의 기본 템플릿 (트리 자료형)
name = ['A', 'B', 'C', 'D', 'E', 'F']

arr = [[0, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]]

def dfs(now):
    print(name[now], end = ' ')
    for i in range(6):
        if arr[now][i] == 1:
            dfs(i)

dfs(0) # 시작인덱스

# DFS의 기본 템플릿 (그래프형 - 양방향 존재)
name = ['A', 'B', 'C', 'D']

arr = [[0, 1, 1, 0],
       [0, 0, 1, 1],
       [1, 1, 0, 1],
       [0, 0, 0, 0]]
used = [0] * 4

def dfs(now):
    print(name[now], end = ' ')
    for i in range(4):
        if arr[now][i] == 1 and used[i] == 0:
            used[i] = 1
            dfs(i)


used[0] = 1 # 탐색 시작 인덱스에 해당하는 used 배열 값을 1체크하고
dfs(0) # 0번 인덱스 부터 탐색 시작

#DFS의 기본 템플릿 (그래프형 - 양방향 존재 / 인접리스트 이용 / True를 이용항 방문 체크)

# 백준 2606번 바이러스 문제를 통한 기본 템플릿 구현

# 방문 처리 개수 세는 방식
n = int(input()) #노드 번호
m = int(input()) #간선 번호

v = [[] for i in range(n + 1)] # n번 노드가 필요하기 때문에 n + 1개의 range

for i in range(m):
    a, b = map(int, input().split())

    v[a].append(b)
    v[b].append(a) # 양방향이기 때문에 b에 a를 append

# DFS 일반적인 코드

visited = [False for i in range(n + 1)]

def dfs(cur):
    visited[cur] = True

    for nxt in v[cur]:
        if visited[nxt]:
            continue

        dfs(nxt)

dfs(1)

cnt = 0
for i in range(n + 1):
    if visited[i]:
        cnt += 1

print(cnt - 1)